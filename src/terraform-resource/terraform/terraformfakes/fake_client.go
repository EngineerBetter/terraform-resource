// Code generated by counterfeiter. DO NOT EDIT.
package terraformfakes

import (
	"sync"
	"terraform-resource/terraform"
)

type FakeClient struct {
	InitWithBackendStub        func(string) error
	initWithBackendMutex       sync.RWMutex
	initWithBackendArgsForCall []struct {
		arg1 string
	}
	initWithBackendReturns struct {
		result1 error
	}
	initWithBackendReturnsOnCall map[int]struct {
		result1 error
	}
	InitWithoutBackendStub        func() error
	initWithoutBackendMutex       sync.RWMutex
	initWithoutBackendArgsForCall []struct{}
	initWithoutBackendReturns     struct {
		result1 error
	}
	initWithoutBackendReturnsOnCall map[int]struct {
		result1 error
	}
	ApplyStub        func() error
	applyMutex       sync.RWMutex
	applyArgsForCall []struct{}
	applyReturns     struct {
		result1 error
	}
	applyReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	PlanStub        func() error
	planMutex       sync.RWMutex
	planArgsForCall []struct{}
	planReturns     struct {
		result1 error
	}
	planReturnsOnCall map[int]struct {
		result1 error
	}
	OutputStub        func() (map[string]map[string]interface{}, error)
	outputMutex       sync.RWMutex
	outputArgsForCall []struct{}
	outputReturns     struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	outputReturnsOnCall map[int]struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	VersionStub        func() (string, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct{}
	versionReturns     struct {
		result1 string
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ImportStub        func() error
	importMutex       sync.RWMutex
	importArgsForCall []struct{}
	importReturns     struct {
		result1 error
	}
	importReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceListStub        func() ([]string, error)
	workspaceListMutex       sync.RWMutex
	workspaceListArgsForCall []struct{}
	workspaceListReturns     struct {
		result1 []string
		result2 error
	}
	workspaceListReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	StatePullStub        func(string) (map[string]interface{}, error)
	statePullMutex       sync.RWMutex
	statePullArgsForCall []struct {
		arg1 string
	}
	statePullReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	statePullReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) InitWithBackend(arg1 string) error {
	fake.initWithBackendMutex.Lock()
	ret, specificReturn := fake.initWithBackendReturnsOnCall[len(fake.initWithBackendArgsForCall)]
	fake.initWithBackendArgsForCall = append(fake.initWithBackendArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("InitWithBackend", []interface{}{arg1})
	fake.initWithBackendMutex.Unlock()
	if fake.InitWithBackendStub != nil {
		return fake.InitWithBackendStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initWithBackendReturns.result1
}

func (fake *FakeClient) InitWithBackendCallCount() int {
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	return len(fake.initWithBackendArgsForCall)
}

func (fake *FakeClient) InitWithBackendArgsForCall(i int) string {
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	return fake.initWithBackendArgsForCall[i].arg1
}

func (fake *FakeClient) InitWithBackendReturns(result1 error) {
	fake.InitWithBackendStub = nil
	fake.initWithBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithBackendReturnsOnCall(i int, result1 error) {
	fake.InitWithBackendStub = nil
	if fake.initWithBackendReturnsOnCall == nil {
		fake.initWithBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackend() error {
	fake.initWithoutBackendMutex.Lock()
	ret, specificReturn := fake.initWithoutBackendReturnsOnCall[len(fake.initWithoutBackendArgsForCall)]
	fake.initWithoutBackendArgsForCall = append(fake.initWithoutBackendArgsForCall, struct{}{})
	fake.recordInvocation("InitWithoutBackend", []interface{}{})
	fake.initWithoutBackendMutex.Unlock()
	if fake.InitWithoutBackendStub != nil {
		return fake.InitWithoutBackendStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initWithoutBackendReturns.result1
}

func (fake *FakeClient) InitWithoutBackendCallCount() int {
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	return len(fake.initWithoutBackendArgsForCall)
}

func (fake *FakeClient) InitWithoutBackendReturns(result1 error) {
	fake.InitWithoutBackendStub = nil
	fake.initWithoutBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackendReturnsOnCall(i int, result1 error) {
	fake.InitWithoutBackendStub = nil
	if fake.initWithoutBackendReturnsOnCall == nil {
		fake.initWithoutBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithoutBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Apply() error {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct{}{})
	fake.recordInvocation("Apply", []interface{}{})
	fake.applyMutex.Unlock()
	if fake.ApplyStub != nil {
		return fake.ApplyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.applyReturns.result1
}

func (fake *FakeClient) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *FakeClient) ApplyReturns(result1 error) {
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ApplyReturnsOnCall(i int, result1 error) {
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyReturns.result1
}

func (fake *FakeClient) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeClient) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DestroyReturnsOnCall(i int, result1 error) {
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Plan() error {
	fake.planMutex.Lock()
	ret, specificReturn := fake.planReturnsOnCall[len(fake.planArgsForCall)]
	fake.planArgsForCall = append(fake.planArgsForCall, struct{}{})
	fake.recordInvocation("Plan", []interface{}{})
	fake.planMutex.Unlock()
	if fake.PlanStub != nil {
		return fake.PlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.planReturns.result1
}

func (fake *FakeClient) PlanCallCount() int {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	return len(fake.planArgsForCall)
}

func (fake *FakeClient) PlanReturns(result1 error) {
	fake.PlanStub = nil
	fake.planReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PlanReturnsOnCall(i int, result1 error) {
	fake.PlanStub = nil
	if fake.planReturnsOnCall == nil {
		fake.planReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.planReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Output() (map[string]map[string]interface{}, error) {
	fake.outputMutex.Lock()
	ret, specificReturn := fake.outputReturnsOnCall[len(fake.outputArgsForCall)]
	fake.outputArgsForCall = append(fake.outputArgsForCall, struct{}{})
	fake.recordInvocation("Output", []interface{}{})
	fake.outputMutex.Unlock()
	if fake.OutputStub != nil {
		return fake.OutputStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.outputReturns.result1, fake.outputReturns.result2
}

func (fake *FakeClient) OutputCallCount() int {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return len(fake.outputArgsForCall)
}

func (fake *FakeClient) OutputReturns(result1 map[string]map[string]interface{}, result2 error) {
	fake.OutputStub = nil
	fake.outputReturns = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputReturnsOnCall(i int, result1 map[string]map[string]interface{}, result2 error) {
	fake.OutputStub = nil
	if fake.outputReturnsOnCall == nil {
		fake.outputReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]interface{}
			result2 error
		})
	}
	fake.outputReturnsOnCall[i] = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Version() (string, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct{}{})
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.versionReturns.result1, fake.versionReturns.result2
}

func (fake *FakeClient) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeClient) VersionReturns(result1 string, result2 error) {
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) VersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Import() error {
	fake.importMutex.Lock()
	ret, specificReturn := fake.importReturnsOnCall[len(fake.importArgsForCall)]
	fake.importArgsForCall = append(fake.importArgsForCall, struct{}{})
	fake.recordInvocation("Import", []interface{}{})
	fake.importMutex.Unlock()
	if fake.ImportStub != nil {
		return fake.ImportStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.importReturns.result1
}

func (fake *FakeClient) ImportCallCount() int {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	return len(fake.importArgsForCall)
}

func (fake *FakeClient) ImportReturns(result1 error) {
	fake.ImportStub = nil
	fake.importReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportReturnsOnCall(i int, result1 error) {
	fake.ImportStub = nil
	if fake.importReturnsOnCall == nil {
		fake.importReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceList() ([]string, error) {
	fake.workspaceListMutex.Lock()
	ret, specificReturn := fake.workspaceListReturnsOnCall[len(fake.workspaceListArgsForCall)]
	fake.workspaceListArgsForCall = append(fake.workspaceListArgsForCall, struct{}{})
	fake.recordInvocation("WorkspaceList", []interface{}{})
	fake.workspaceListMutex.Unlock()
	if fake.WorkspaceListStub != nil {
		return fake.WorkspaceListStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.workspaceListReturns.result1, fake.workspaceListReturns.result2
}

func (fake *FakeClient) WorkspaceListCallCount() int {
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	return len(fake.workspaceListArgsForCall)
}

func (fake *FakeClient) WorkspaceListReturns(result1 []string, result2 error) {
	fake.WorkspaceListStub = nil
	fake.workspaceListReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.WorkspaceListStub = nil
	if fake.workspaceListReturnsOnCall == nil {
		fake.workspaceListReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.workspaceListReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StatePull(arg1 string) (map[string]interface{}, error) {
	fake.statePullMutex.Lock()
	ret, specificReturn := fake.statePullReturnsOnCall[len(fake.statePullArgsForCall)]
	fake.statePullArgsForCall = append(fake.statePullArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("StatePull", []interface{}{arg1})
	fake.statePullMutex.Unlock()
	if fake.StatePullStub != nil {
		return fake.StatePullStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.statePullReturns.result1, fake.statePullReturns.result2
}

func (fake *FakeClient) StatePullCallCount() int {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	return len(fake.statePullArgsForCall)
}

func (fake *FakeClient) StatePullArgsForCall(i int) string {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	return fake.statePullArgsForCall[i].arg1
}

func (fake *FakeClient) StatePullReturns(result1 map[string]interface{}, result2 error) {
	fake.StatePullStub = nil
	fake.statePullReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StatePullReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.StatePullStub = nil
	if fake.statePullReturnsOnCall == nil {
		fake.statePullReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.statePullReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ terraform.Client = new(FakeClient)
